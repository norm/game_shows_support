#!/usr/bin/env -S bash -euo pipefail
#
# Preview new raw footage, then convert all/some as needed. For each
# new piece of footage, create a text file for capturing the contents
# of the footage for later reference, and a Things task to track
# whether or not this has been done.

function convert_raw_footage {
    local source="$1"
    local target="$2"
    local start="${3:-}"
    local end="${4:-}"

    local base_target="${2%.*}"
    local destination="$base_target.mkv"
    local extra_args=()
    local increment=1
    local notes

    if [ -n "$start" ]; then
        extra_args+=(-ss "$start")
    fi
    if [ -n "$end" ]; then
        extra_args+=(-to "$end")
    fi

    # generate a unique extension when taking a slice of footage
    # (yes, there's a theoretical race condition; no, it won't happen)
    if [ -n "$start" -o -n "$end" ]; then
        destination="${base_target}-${increment}.mkv"
        while [ -f "$destination" ]; do
            ((increment++))
            destination="${base_target}-${increment}.mkv"
        done

        local slices="$(echo "$source" | sed -e 's/.mkv$/.txt/')"
        printf '   %7s -> %7s\n' "$start" "$end" >> "$slices"
    fi

    # filter out the second audio channel (mic input, not used)
    ffmpeg \
        -y \
        -i "$source" \
        -loglevel error \
        -stats \
        ${extra_args[@]} \
        -map 0 \
        -map -0:a:1 \
        -codec copy \
        "$destination"

    # copy to the SSD
    rsync \
        --itemize-changes \
        --progress \
            "$destination" \
            "$FAST_VIDEO_DIR/Game Shows/$GAME_SHOW_NAME/$destination"

    notes="$(echo "$destination" | sed -e 's/.mkv$/.txt/')"
    if [ ! -f "$notes" ]; then
        cat footage/template.txt > "$notes"
        add_to_things "Properly annotate $destination"
    fi
    subl "$notes"
}

function seconds_from_timestamp {
    local timestamp="$1"

    local seconds="${timestamp##*:}"
    timestamp="${timestamp%:*}"

    local minutes="${timestamp##*:}"
    ((seconds += minutes * 60))

    # M:S is lowest expectation, not H:M:S
    if grep : <(echo $timestamp) >/dev/null; then
        timestamp="${timestamp%:*}"
        ((seconds += ${timestamp%:*} * 60 * 60))
    fi

    echo $seconds
}

function slice_duration {
    local start="${1:-}"
    local end="${2:-}"
    local total="${3:-}"

    [ -z "$start" ] && start='0:00'
    [ -z "$end" ] && end="$total"

    local start_seconds=$(seconds_from_timestamp "$start")
    local end_seconds=$(seconds_from_timestamp "$end")

    local total_seconds=$((end_seconds - start_seconds))
    local seconds=$((total_seconds % 60))
    local minutes=$((total_seconds / 60 % 60))
    local hours=$((total_seconds / 60 / 60 % 24))

    local duration=''
    [ $hours -gt 0 ] && duration="$hours:"
    [ $minutes -gt 0 ] && duration+="$(printf '%02d:' $minutes)"
    duration+="$(printf '%02d' $seconds)"

    if [ $(($total_seconds * 60)) -gt 99999 ]; then
        # frame count clicks over, pushing the text by one
        printf '%50s%8s\n' '=' $duration
    else
        printf '%49s%8s\n' '=' $duration
    fi
}


mapfile -t captures < <(ls -t raw/*mkv 2>/dev/null)
for capture in "${captures[@]}"; do
    file="$(basename "$capture")"
    [ "$file" = '*mkv' ] && break

    destination="footage/$file"
    slices="$(echo "$capture" | sed -e 's/.mkv$/.txt/')"

    if [ ! -f "$destination" ]; then
        # can mark a raw file as being "done"
        grep done "$slices" >/dev/null 2>&1 && continue

        duration=$(duration "$capture")
        status "++ {green}$file [$duration]"
        [ -n "${DRY_RUN:-}" ] && continue

        play "$capture"

        [ -f "$slices" ] && {
            echo "   Existing slices taken:"
            cat "$slices"
        }

        chose=0
        index=1
        while [ $chose = 0 ]; do
            status -cnr "[A]:Use All [S]:Use Slice [D]:Done [R]:Remove [ ]:Skip - Keep? "
            read -N1 -s keeper
            echo $keeper
            case $keeper in
                a|A)
                    convert_raw_footage "$capture" "$destination"
                    chose=1
                    ;;

                s|S)
                    read -p "   From: " start_time
                    read -p "   To:   " end_time
                    slice_duration "$start_time" "$end_time" "$duration"
                    convert_raw_footage "$capture" "$destination" "$start_time" "$end_time"
                    ;;

                d|D)
                    echo "done" >> "$slices"
                    chose=1
                    ;;

                r|R)
                    rm "$capture"
                    chose=1
                    ;;

                ' ')
                    chose=1
                    ;;

                *)
                    echo "Unknown option: '$keeper'"
                    sleep 1
                    ;;
            esac
        done
        echo ''
    fi
done
