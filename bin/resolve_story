#!/usr/bin/env python

import argparse
import csv
from functools import cmp_to_key
import networkx as nx
import os
from pprint import pformat
import string
import textwrap
import sys
import toml


# FIXME
# copy output to story.txt


parser = argparse.ArgumentParser()
parser.add_argument('--csv', action='store_true')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--main', action='store_true')
parser.add_argument('--outline', action='store_true')
parser.add_argument('--edges', action='store_true')
parser.add_argument('--graph', action='store_true')
parser.add_argument('--test', action='store_true')
parser.add_argument('--skip', action='store_true')
parser.add_argument('--no-errors', action='store_true')
args = parser.parse_args()


errors = False

# abandoned -> reminders -> completed -> remaining threads
story = toml.load(os.path.join('story', 'story.toml'))
graph = nx.DiGraph()
graph.add_node(
    'abandoned',
    text = '',
    location = 'start',
    type = 'marker',
    context = 'ABANDONED',
)
graph.add_node(
    'abandoned_end',
    text = 'END OF ABANDONED',
    location = 'start',
    type = 'border',
    context = 'ABANDONED',
)
graph.add_edge('abandoned', 'abandoned_end')
graph.add_edge('abandoned_end', 'reminders')

graph.add_node(
    'reminders',

    text = 'REMINDERS',
    location = 'current',
    type = 'border',
    context = 'REMINDERS',
)
graph.add_node(
    'reminders_end',
    text = 'COMPLETED',
    location = 'current',
    type = 'border',
    context = 'REMINDERS',
)
graph.add_edge('reminders', 'reminders_end')
graph.add_edge('reminders_end', 'story')

graph.add_node(
    'completed',
    text = '',
    location = 'current',
    type = 'border',
    context = 'COMPLETED',
)
graph.add_node(
    'completed_end',
    text = 'RECORDING STARTS HERE',
    location = 'current',
    type = 'border',
    context = 'COMPLETED',
)
graph.add_edge('completed', 'completed_end')

last_reminder = 'reminders'
for thread in story['reminders']:
    graph.add_edge(last_reminder, thread)
    graph.add_edge(thread, 'reminders_end')
    last_reminder = thread
for thread in story['completed_threads']:
    graph.add_edge('%s_end' % thread, 'completed')
for node in story['completed_nodes']:
    graph.add_edge(node, 'completed')

for root, dirs, files in os.walk('story'):
    category = root[6:]
    for file in files:
        if not file.endswith('.toml'):
            continue

        thread = toml.load(os.path.join(root, file))
        node = os.path.join(category, file[:-5])

        for key in ('title', 'type'):
            if key not in thread:
                print('** %s missing from "%s"' % (key, node))
                errors = True

        if thread['type'] in ('location', 'reminder'):
            thread['start'] = thread['location']
            thread['end'] = thread['location']

        for key in ('start', 'end'):
            if key not in thread:
                print('** %s missing from "%s"' % (key, node))
                errors = True

        last_node = node
        location = thread['start']
        if 'begin' in thread:
            graph.add_node(
                node,
                action=True,
                location=location,
                text=thread['begin'],
                context=thread['title'],
                thread=node,
                type=thread['type'],
            )
        else:
            if (
                thread['type'] not in ('marker', 'location')
                and 'autobegin' not in thread
            ):
                print('** no begin in "%s"' % node)
                errors = True
            graph.add_node(
                node,
                location=location,
                text=thread['title'],
                context=thread['title'],
                thread=node,
                type=thread['type'],
                autobegin='autobegin' in thread,
            )

        if 'action' in thread:
            for index, action in enumerate(thread['action']):
                node_id = '%s_%s' % (node, index)
                if 'location' in action:
                    location = action['location']
                graph.add_node(
                    node_id,
                    action=True,
                    location=location,
                    text=action['text'],
                    context=thread['title'],
                    thread=node,
                    type=thread['type'],
                )
                graph.add_edge(last_node, node_id)
                last_node = node_id

        node_id = '%s_end' % node
        graph.add_node(
            node_id,
            location=thread['end'],
            text='',
            context=thread['title'],
            thread=node,
            type=thread['type'],
        )
        graph.add_edge(last_node, node_id)
        last_node = node_id

        # this mission immediately starts another
        if 'triggers' in thread:
            graph.add_edge(last_node, thread['triggers'])

        # this mission unlocks further missions
        # (so they necessarily come after)
        if 'unlocks' in thread:
            for unlock in thread['unlocks']:
                graph.add_edge(last_node, unlock)

        # this mission MUST be completed before some point
        if 'finish_before' in thread:
            for before in thread['finish_before']:
                graph.add_edge(last_node, before)

        # editorial ordering
        if 'before' in thread:
            for before in thread['before']:
                graph.add_edge(last_node, before)

        # editorial ordering
        if 'after' in thread:
            for after in thread['after']:
                graph.add_edge('%s_end' % after, node)

        # post actions come after the "end" of the mission,
        # because they can be resolved at your leisure;
        # they have the same unlocks/finish_before/before/after links
        # available as the main mission
        if 'post_action' in thread:
            last_post = last_node
            for index, action in enumerate(thread['post_action']):
                node_id = '%s_post_%s' % (node, index)
                if 'location' in action:
                    location = action['location']
                else:
                    location = thread['end']
                graph.add_node(
                    node_id,
                    action=True,
                    location=location,
                    text=action['text'],
                    context=thread['title'],
                    type=thread['type'],
                )
                graph.add_edge(last_node, node_id)
                if 'chained' in action:
                    graph.add_edge(last_post, node_id)
                if 'unlocks' in action:
                    for unlock in action['unlocks']:
                        graph.add_edge(node_id, unlock)
                if 'finish_before' in action:
                    for before in action['finish_before']:
                        graph.add_edge(node_id, before)
                if 'before' in action:
                    for before in action['before']:
                        graph.add_edge(node_id, before)
                if 'after' in action:
                    for after in action['after']:
                        graph.add_edge('%s_end' % after, node_id)
                last_post = node_id


# remove storyline edges for abandoned threads/nodes,
# then connect them to abandoned for sorting
remove_edges = []
for thread in story['abandoned_threads']:
    for edge in graph.edges:
        if edge[0].startswith(thread) and not edge[1].startswith(thread):
            remove_edges.append(edge)
        if edge[1].startswith(thread) and not edge[0].startswith(thread):
            remove_edges.append(edge)
    graph.add_edge('%s_end' % thread, 'abandoned_end')
    graph.add_edge('abandoned', thread)
for edge in remove_edges:
    if args.debug:
        print('-- removing edge', edge)
    graph.remove_edge(*edge)

remove_edges = []
for node in story['abandoned_nodes']:
    for edge in graph.edges:
        if edge[0] == node or edge[1] == node:
            remove_edges.append(edge)
    graph.add_edge('abandoned', node)
for edge in remove_edges:
    if args.debug:
        print('-- removing edge', edge)
    graph.remove_edge(*edge)


if not nx.is_directed_acyclic_graph(graph):
    print('** LOOP FOUND')
    cycle = list(nx.find_cycle(graph, orientation='original'))
    print("   '%s' [%s]" % (graph.nodes[cycle[0][0]]['text'], cycle[0][0]))
    for index in cycle[1:]:
        print("      => '%s' [%s]" % (
            graph.nodes[index[1]]['text'],
            index[1],
        ))
    sys.exit(2)


if args.debug:
    print(' == NODES')
    nodes = list(graph.nodes)
    for node in nodes:
        print('   ', node, graph.nodes[node])

if args.debug or args.edges:
    print(' == EDGES')
    for edge in graph.edges:
        print('   ', edge)

if args.debug or args.graph:
    print(' == GRAPH')
    for index in nx.topological_generations(graph):
        print('   ', index)
    print()


if args.edges or args.graph:
    sys.exit()

# check for nodes that have been referenced but not actually populated
# (generally created with unlocks/before/after/... which has a typo)
for node in graph.nodes:
    if graph.nodes[node] == {}:
        sys.exit("node '%s' is unpopulated" % node)

# where threads of equal standing include certain types of threads,
# those threads get elevated out
sorted_graph = []
current_location = ''
for threads in list(nx.topological_generations(graph)):
    def location_before_key(a, b):
        try:
            loc_a = graph.nodes[a]['location']
        except:
            print("** node '%s' has no location" % a)
            print(graph.nodes[a])
            sys.exit(1)
        try:
            loc_b = graph.nodes[b]['location']
        except:
            print("** node '%s' has no location" % b)
            print(graph.nodes[b])
            sys.exit(1)
        if loc_a == current_location and loc_b != current_location:
            return -1
        if loc_b == current_location and loc_a != current_location:
            return 1
        if loc_a != loc_b:
            if sorted([loc_a, loc_b]) != [loc_a, loc_b]:
                return 1
        elif sorted((a, b)) != [a, b]:
            return 1
        return -1

    if len(threads) > 1:
        lift_threads = []
        equal_threads = []
        for thread in threads:
            node = graph.nodes[thread]
            if 'type' in node and node['type'] == 'border':
                sorted_graph.append([thread])
            elif '_post_' in thread:
                lift_threads.append(thread)
            else:
                equal_threads.append(thread)
        if len(lift_threads):
            sorted_graph.append(
                sorted(lift_threads, key=cmp_to_key(location_before_key))
            )
        if len(equal_threads):
            sorted_graph.append(
                sorted(equal_threads, key=cmp_to_key(location_before_key))
            )
    else:
        if 'location' in graph.nodes[threads[0]]:
            current_location = graph.nodes[threads[0]]['location']
        sorted_graph.append(threads)


if args.csv:
    step = 0
    current_location = ''
    with open('story.csv', 'w') as handle:
        writer = csv.DictWriter(
            handle,
            fieldnames=['step','location','node','text']
        )
        writer.writeheader()

        for threads in sorted_graph:
            step += 1
            for index, node_id in enumerate(threads):
                node = graph.nodes[node_id]

                if 'location' in node:
                    current_location = node['location']

                row = {
                    'location': current_location,
                    'node': node_id,
                }
                if 'text' in node:
                    row['text'] = node['text']
                if index == 0:
                    row['step'] = step

                writer.writerow(row)


current_location = ''
current_context = ''
used = {}
skipping = args.skip
for threads in sorted_graph:
    def print_node(node_id, indent='  '):
        node = graph.nodes[node_id]
        if node['location'] == 'current':
            node['location'] = current_location
        location = ' {%s}' % node['location']
        bullet = ' '

        if (
            current_location != node['location']
            and (
                current_context != node['context']
                or
                '_post_' in node_id
            )
        ):
            context = ''
            if not '_post_' in node_id:
                context = ' for %s' % node['context']
            if node['type'] != 'border':
                print('\n'.join(
                    textwrap.wrap(
                        '  %s%s' % (
                            'Go to %s' % node['location'],
                            context,
                        ),
                        initial_indent=indent[2:],
                        subsequent_indent=indent,
                        width = 80,
                    )
                ))
        if 'type' in node and node['type'] == 'border':
            print('\n%s\n' % (' %s ' % node['text']).center(80, '='))
        elif 'type' in node and node['type'] == 'marker':
            print('\n==== %s ====' % node['text'])
        else:
            bullet = '.'
            if node['type'] == 'story':
                bullet = '*'
                if '_post_' in node_id:
                    bullet = '-'
            print('\n'.join(
                textwrap.wrap(
                    '%s%s %s [%s]' % (
                        bullet,
                        location,
                        node['text'], 
                        node['context'],
                    ),
                    initial_indent=indent[2:],
                    subsequent_indent=indent,
                    width = 80,
                )
            ))

    output_nodes = []

    if args.debug:
        print('<', threads)
    for index in threads:
        node = graph.nodes[index]
        used[index] = 1
        if not args.test:
            if (
                    'autobegin' in node
                and node['autobegin']
                and node['type'] != 'marker'
            ):
                continue
            if 'text' in node and node['text']:
                if args.main:
                    if node['type'] in ('story', 'marker', 'border'):
                        output_nodes.append(index)
                else:
                    output_nodes.append(index)

    if 'reminders' in threads:
        skipping = False
    if 'completed_end' in threads:
        skipping = False
    if 'reminders_end' in threads:
        skipping = args.skip

    if args.debug:
        print('>', output_nodes)
    if not skipping:
        if len(output_nodes) == 1:
            if args.outline:
                print(output_nodes[0])
            else:
                print_node(output_nodes[0])
        elif len(output_nodes) > 1:
            if args.outline:
                print('--- %d equal options' % len(output_nodes))
                for index in output_nodes:
                    print('   ', index)
            else:
                print(
                    '--- %d equal options:\n      [%s]' % (
                        len(output_nodes),
                        pformat(
                            [ index for index in output_nodes ],
                            indent = 7,
                            width = 80,
                            compact = True,
                        )[1:-1].lstrip(),
                    )
                )
                for index in output_nodes:
                    print_node(index, indent='      ')

    # update the current location and context, but only if there is 
    # one definitive change
    new_locations = set()
    new_contexts = set()
    for thread in threads:
        node = graph.nodes[thread]
        if node['location'] == 'current':
            node['location'] = current_location
        if 'location' in node:
            new_locations.add(node['location'])
        if 'context' in node:
            new_contexts.add(node['context'])
    if len(new_locations) == 1:
        location = list(new_locations)[0]
        if args.debug and current_location != location:
            print('  location: %s => %s' % (current_location, location))
        current_location = location
    if len(new_contexts) == 1:
        context = list(new_contexts)[0]
        if args.debug and current_context != context:
            print('  context: %s => %s' % (current_context, context))
        current_context = context

    if 'reminders_end' in threads:
        skipping = args.skip

if not args.no_errors:
    # look for missing or unused nodes
    for threads in sorted_graph:
        for index in threads:
            node = graph.nodes[index]
            if 'text' not in node:
                print('** node "%s" not populated' % index)
                errors = True
            if index not in used:
                print('** node "%s" not used' % index)
                errors = True

    # look for nodes without placement
    for threads in sorted_graph:
        if 'abandoned' in threads and len(threads) > 1:
            for node in threads:
                if node == 'abandoned':
                    continue
                print('** node "%s" not correctly placed' % node)
                errors = True

if args.test and errors:
    sys.exit(1)
